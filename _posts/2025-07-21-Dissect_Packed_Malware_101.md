---
layout: post
title: Dissect Packed Malware 101
subtitle: Understand malicious software compressed or encrypted by packer to hide its true code, evading detection and analysis.
---

>


# Layers of Evasion and Defense 
First of all, **what it is a packer?** A packer is a tool that compresses and encrypts executable files to hide their true code. Lawfully are used to protect software from piracy and reverse engineering in order to safeguard intellectual property. In cyber threats, attackers use packers to conceal malware, making it difficult for EDRs and analysts to detect or analyze it. 
Packed malware unpacks itself only during execution, evading static detection methods, increasing stealth, complicates reverse engineering and allows malware to bypass security defenses. Packers can be standard or custom-built, often combined with other evasion tactics. 

<img width="692" height="699" alt="image" src="https://github.com/user-attachments/assets/8ec97294-4e0a-4846-b528-d20c1d4ab965" />

---

## Packed Malware Anatomy and Unpacking Process

Shown below an overview of the same sample, left in its original form, right in its packed form. The **executable‚Äôs entry point** point to different location, in the packed version it directs to the unpacking stub rather than the original code.
Nonpacked executables are loaded directly by the operating system. In contrast, for packed programs, the OS loads a small unpacking stub first, which then loads the original program.
The stub is usually minimal and its sole purpose is to unpack the original program. Static analysis of a packed file only analyzes the stub, not the original code. 

![image](https://github.com/user-attachments/assets/bc3b15e4-18e1-40a8-aea1-9cf702ca22fe)

The unpacking stub performs three main tasks: 
- unpack (load) the original executable into memory
- transfer execution to the original entry point
- resolve its imports
#### Loading in Memory
The process to load in memory it's basically the same, but differ from a single thing, who/what loads in memory needed code. 
When **not-packed executables** are loaded in memory, the loader reads the PE header from the disk and allocate memory for each section, then it transfers the sections into the allocated memory areas. 
For **packed executables**, the PE header is also structured to ensure the loader allocates space for the sections, which may either come from the original program or be generated by the unpacking stub. The unpacking stub decompresses/decrypts the code for each section and places it into the designated memory locations. The key difference is that, for packed executables, the loader initially loads a small unpacking stub instead of the original code. This stub is responsible for unpacking the actual executable code into memory, resolving imports, and then transferring control to the original program‚Äôs entry point.
#### Restore the OEP
Another important and crucial task that is performed during sample unpacking is the restore of the Original Entry Point. To do so, the sample must transfer execution to the OEP, and the best instruction that transfer execution to another portion of code is `jump`. This instruction is so called "**tail jump**" and it is the most important thing that an analyst must recognize and intercept in order to unpack a packed malware.
#### Resolve Imports
The Windows loader cannot interpret import information when the executable file it is packed, the unpacking stub is responsible for resolving imports.
Typically, the stub imports only the essential functions `LoadLibrary` and `GetProcAddress`. After unpacking the original program, it reads the original import table, calls `LoadLibrary` to load each required DLL, and then uses `GetProcAddress` to locate each imported function. 

---
## How identify packed sample

When malware is packed, analysts usually only have access to the packed file and cannot directly examine the original unpacked program or the tool that packed it. To unpack the executable, analysts must reverse the packing process, which requires a thorough understanding of how the specific packer functions. This knowledge is essential to effectively restore the malware to its original form for analysis.

<img width="698" height="698" alt="image" src="https://github.com/user-attachments/assets/05c32503-3349-4977-9562-19ef4cf8a691" />

#### Packed Software Indicators
if someone of this are highlighted looking at a suspicious sample, it may be a packed one.
- Bin sections with strange names;
- Huge gap between the raw size and the virtual size of the bin sections;
- Highlighted the presence of a packed sample by debuggers and tools such as PEiD;
- Few readable strings, sometimes none;
- Few imports, sometimes only `LoadLibrary` and `GetProcAddress`;

---
## Automated Unpacking

Unpack a packed software it can be done by related unpackers. Most are open source and community maintained. De4dot (e.g.) is a tool used for this purpose, deobfuscating/unpacking .NET samples. Unpac.me is another online tool that can be used to automate unpacking process.
Simply giving to the unpacker software the packed one and voil√†, the unpacking process is done.
Simple as boring, no juicy example here. 
But tools and open source unpackers don't work always, skip to the next section to understand why.

---

## Manual Unpacking

<img width="698" height="699" alt="image" src="https://github.com/user-attachments/assets/c956ccd2-42e6-43fb-8ca2-7ed68156ecdc" />

Sometimes (more often than we think), unpack malwares is not simple and automatic as we hope, so it must be necessary try to unpack manually. Malware creators have a wide range of packers to choose from. Some packers are legitimate commercial tools designed for regular software developers, while others are specifically developed to aid malicious software. Some malware is protected by custom packers, for this reason its important understand how a packer works in order to reverse what it did on the malware and **extract the evil inside of it**.
#### Common procedure: 
1. find tail`jump` or juicy instructions and reach the "real" OEP;
2. dump the evil within;
3. repair IAT; 
4. restore OEP;

Let's look at different ways to do manual unpacking of a malware packed, starting from something simple to something more complex.

---

### ü¶†üîç Specimen #1 - last jump before a lot of zer0s
<img width="692" height="41" alt="image" src="https://github.com/user-attachments/assets/34ecda1e-f96b-4d4d-a1f2-8cfce53b468f" />

Let's start to manually unpack a malware that is packed with UPX, which is free, common and relatively simple to unpack. UPX includes its own unpacking functionality, so if malware is compressed with a standard version of UPX, we can use the UPX utility to extract the original file. However, malware developers sometimes modify UPX or alter the header of the packed executable to hinder unpacking. Unlike UPX, most other packers lack integrated unpacking features, making it crucial to know how to handle various types of packed software. 

<img width="609" height="106" alt="image" src="https://github.com/user-attachments/assets/1862f914-f461-47f1-b1cb-aad4bd5728a2" />

By loading the sample into SpeakEasy we can see that the presence of the UPX packer (modified version) is identified, if we tried to use UPX to unpack it, we would fail. **Manual unpacking is therefore necessary**. 

UPX packer is famous to unpack packed code after a jump instruction right before some null values:

<img width="493" height="523" alt="image" src="https://github.com/user-attachments/assets/f39dedcb-6cc3-4ac5-9a8a-87b3bad98781" />

Viewing the contents of the memory segment before the execution of the `jmp` instruction (our tail jump) we notice that it is not populated

<img width="689" height="392" alt="image" src="https://github.com/user-attachments/assets/b5cdafcc-4582-425f-a5ac-c79779e9c77c" />

upon hitting bpx setted we notice that the memory segment to which our tail jump points is now full of instructions, probably (it is) our binary now loaded (unpacked) correctly into memory

<img width="701" height="349" alt="image" src="https://github.com/user-attachments/assets/19e74311-3413-40c4-af28-19cf171ab756" />

we indeed observe a function epilogue (highlighted), aimed to save the stack pointer.

<img width="647" height="245" alt="image" src="https://github.com/user-attachments/assets/647e83e1-91a0-4a7a-9c46-0084915a4b3e" />

Inspecting function calls present the memory region we are in we have several pieces of information that lead us to think we are correctly in the now unpacked portion of the binary code. Otherwise we would not have so many calls, especially not so clearly readable ones.

<img width="1050" height="593" alt="image" src="https://github.com/user-attachments/assets/feac1585-2491-4360-9507-1540d59b5811" />

Now that we have the unpacked sample loaded into memory, we need to dump it and restore IAT and OEP. 
How? with the plugin OllyDumpEx we can feed it the binary dump and restore the OEP by matching it to the instruction pointer.

<img width="1056" height="353" alt="image" src="https://github.com/user-attachments/assets/3dc156ae-a245-4f77-bca3-1c2d9efe57db" />

then, with another tool named Scylla we can restore the IAT and fix the process dumped 

<img width="424" height="600" alt="image" src="https://github.com/user-attachments/assets/1f4990f1-f7af-4963-81e9-35d5ee2c308b" />

Once the 3 steps are done: unpack the binary (1) and restore OEP (2) an IAT (3), we can now start to analyze the sample as we want. Comparing the two different samples, the version packed and the one unpacked, we can notice visible differences, highlighting clear information in the unpacked version.

<img width="525" height="509" alt="image" src="https://github.com/user-attachments/assets/a4a62c37-b5b5-400d-a4bc-20e3665016d1" />

the morphology of the binary sections is an indicator (in this case) of a packed sample, in addition to the fact that we have a section called UPX2, we can see the large gap between raw size and virtual size of the bin sections, also an indicator of a packed sample. In the version of the sample following the unpacking process we can see how this discrepancy is diminished.

<img width="1161" height="557" alt="image" src="https://github.com/user-attachments/assets/92348dff-8ecc-430e-a616-13684fc10719" />

As indicated at the beginning, the unpacking of this sample was not complicated. We continue by experimenting with another type of packer packed sample.

---
### ü¶†üîç Specimen #2 - Let's jump out of section boundaries


















---

# AI-Podcast - hear me out!
### generated for fun with AI
<iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2020203861&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true"></iframe><div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;"><a href="https://soundcloud.com/5hidobu" title="5hidobu" target="_blank" style="color: #cccccc; text-decoration: none;">5hidobu</a> ¬∑ <a href="https://soundcloud.com/5hidobu/pebby-injector" title="PEBby Injector" target="_blank" style="color: #cccccc; text-decoration: none;">PEBby Injector</a></div>












