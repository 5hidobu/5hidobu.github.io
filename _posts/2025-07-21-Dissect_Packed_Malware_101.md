---
layout: post
title: Dissect Packed Malware 101
subtitle: Understand malicious software compressed or encrypted by packer to hide its true code, evading detection and analysis.
---

>


# Layers of Evasion and Defense 
First of all, **what it is a packer?** A packer is a tool that compresses and encrypts executable files to hide their true code. Lawfully are used to protect software from piracy and reverse engineering in order to safeguard intellectual property. In cyber threats, attackers use packers to conceal malware, making it difficult for EDRs and analysts to detect or analyze it. 
Packed malware unpacks itself only during execution, evading static detection methods, increasing stealth, complicates reverse engineering and allows malware to bypass security defenses. Packers can be standard or custom-built, often combined with other evasion tactics. 

<img width="692" height="699" alt="image" src="https://github.com/user-attachments/assets/8ec97294-4e0a-4846-b528-d20c1d4ab965" />

---

## Packed Malware Anatomy and Unpacking Process

Shown below an overview of the same sample, left in its original form, right in its packed form. The **executable’s entry point** point to different location, in the packed version it directs to the unpacking stub rather than the original code.
Nonpacked executables are loaded directly by the operating system. In contrast, for packed programs, the OS loads a small unpacking stub first, which then loads the original program.
The stub is usually minimal and its sole purpose is to unpack the original program. Static analysis of a packed file only analyzes the stub, not the original code. 

<img width="1128" height="615" alt="image" src="https://github.com/user-attachments/assets/bc3b15e4-18e1-40a8-aea1-9cf702ca22fe" />


The unpacking stub performs three main tasks: 
- unpack (load) the original executable into memory
- transfer execution to the original entry point
- resolve its imports
#### Loading in Memory
The process to load in memory it's basically the same, but differ from a single thing, who/what loads in memory needed code. 
When **not-packed executables** are loaded in memory, the loader reads the PE header from the disk and allocate memory for each section, then it transfers the sections into the allocated memory areas. 
For **packed executables**, the PE header is also structured to ensure the loader allocates space for the sections, which may either come from the original program or be generated by the unpacking stub. The unpacking stub decompresses/decrypts the code for each section and places it into the designated memory locations. The key difference is that, for packed executables, the loader initially loads a small unpacking stub instead of the original code. This stub is responsible for unpacking the actual executable code into memory, resolving imports, and then transferring control to the original program’s entry point.
#### Restore the OEP
Another important and crucial task that is performed during sample unpacking is the restore of the Original Entry Point. To do so, the sample must transfer execution to the OEP, and the best instruction that transfer execution to another portion of code is `jump`. This instruction is so called "**tail jump**" and it is the most important thing that an analyst must recognize and intercept in order to unpack a packed malware.
#### Resolve Imports
The Windows loader cannot interpret import information when the executable file it is packed, the unpacking stub is responsible for resolving imports.
Typically, the stub imports only the essential functions `LoadLibrary` and `GetProcAddress`. After unpacking the original program, it reads the original import table, calls `LoadLibrary` to load each required DLL, and then uses `GetProcAddress` to locate each imported function. 

---
## How identify packed sample

When malware is packed, analysts usually only have access to the packed file and cannot directly examine the original unpacked program or the tool that packed it. To unpack the executable, analysts must reverse the packing process, which requires a thorough understanding of how the specific packer functions. This knowledge is essential to effectively restore the malware to its original form for analysis.

<img width="698" height="698" alt="image" src="https://github.com/user-attachments/assets/05c32503-3349-4977-9562-19ef4cf8a691" />

#### Packed Software Indicators
if someone of this are highlighted looking at a suspicious sample, it may be a packed one.
- Bin sections with strange names;
- Huge gap between the raw size and the virtual size of the bin sections;
- Highlighted the presence of a packed sample by debuggers and tools such as PEiD;
- Few readable strings, sometimes none;
- Few imports, sometimes only `LoadLibrary` and `GetProcAddress`;

---
## Automated Unpacking

Unpack a packed software it can be done by related unpackers. Most are open source and community maintained. De4dot (e.g.) is a tool used for this purpose, deobfuscating/unpacking .NET samples. Unpac.me is another online tool that can be used to automate unpacking process.
Simply giving to the unpacker software the packed one and voilà, the unpacking process is done.
Simple as boring, no juicy example here. 
But tools and open source unpackers don't work always, skip to the next section to understand why.

---

## Manual Unpacking

<img width="698" height="699" alt="image" src="https://github.com/user-attachments/assets/c956ccd2-42e6-43fb-8ca2-7ed68156ecdc" />

Sometimes (more often than we think), unpack malwares is not simple and automatic as we hope, so it must be necessary try to unpack manually. Malware creators have a wide range of packers to choose from. Some packers are legitimate commercial tools designed for regular software developers, while others are specifically developed to aid malicious software. Some malware is protected by custom packers, for this reason its important understand how a packer works in order to reverse what it did on the malware and **extract the evil inside of it**.
#### Common procedure: 
1. find tail`jump` or juicy instructions and reach the "real" OEP;
2. dump the evil within;
3. repair IAT; 
4. restore OEP;

Let's look at different ways to do manual unpacking of a malware packed, starting from something simple to something more complex.

---













# AI-Podcast - hear me out!
### generated for fun with AI
<iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/2020203861&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true"></iframe><div style="font-size: 10px; color: #cccccc;line-break: anywhere;word-break: normal;overflow: hidden;white-space: nowrap;text-overflow: ellipsis; font-family: Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight: 100;"><a href="https://soundcloud.com/5hidobu" title="5hidobu" target="_blank" style="color: #cccccc; text-decoration: none;">5hidobu</a> · <a href="https://soundcloud.com/5hidobu/pebby-injector" title="PEBby Injector" target="_blank" style="color: #cccccc; text-decoration: none;">PEBby Injector</a></div>












